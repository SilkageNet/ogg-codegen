// Code generated by ogg-codegen. DO NOT EDIT.
package swagger

import (
	"errors"
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/render"
	"github.com/pinealctx/neptune/tex"
	"go.uber.org/zap"
	"net/http"
)

var (
	_ = errors.New
	_ render.Render
	_ tex.JsInt64
)

// 文件类接口

func (w *Wrapper) SetupFileRoutine() {
	w.engine.GET("/file/download", w.before("DownloadFile"), w.authVerifyFunc, w.DownloadFile, w.after("DownloadFile"))
	w.engine.POST("/file/upload", w.before("UploadFile"), w.authVerifyFunc, w.UploadFile, w.after("UploadFile"))
}

type DownloadFileParams struct {
	Lang    LangCode `json:"lang,omitempty"`
	DevType DevType  `json:"dev_type,omitempty"`
	// id 文件ID
	Id string `json:"id"`
}

func (t *DownloadFileParams) Bind(c *gin.Context) error {
	t.Lang = LangCode(c.Query("lang"))
	t.DevType = DevType(c.Query("dev_type"))
	t.Id = c.Query("id")
	return nil
}

func (t *DownloadFileParams) Normalize() {

}

func (t *DownloadFileParams) Valid() error {
	if t == nil {
		return errors.New("params is nil")
	}
	if t.Id == "" {
		return errors.New("id.is.empty")
	}
	return nil
}

func (w *Wrapper) DownloadFile(c *gin.Context) {
	var err error
	var param = &DownloadFileParams{}
	if err = w.bindAndValid(c, param); err != nil {
		w.logError("DownloadFile.bindAndValid.err", zap.Error(err))
		w.reqErrorWrapperFunc(c, err)
		return
	}
	w.logDebug("DownloadFile", zap.Reflect("param", param))
	var res *FileData
	if res, err = w.server.DownloadFile(c, param); err != nil {
		w.logError("DownloadFile.err", zap.Reflect("param", param), zap.Error(err))
		w.errorWrapperFunc(c, err)
		return
	}
	w.logDebug("DownloadFile.rsp", zap.Reflect("param", param))
	w.serveFile(c, res)
}

func (m *MockServer) DownloadFile(c *gin.Context, params *DownloadFileParams) (*FileData, error) {
	return nil, nil
}

type UploadFileParams struct {
	Lang    LangCode `json:"lang,omitempty"`
	DevType DevType  `json:"dev_type,omitempty"`
}

func (t *UploadFileParams) Bind(c *gin.Context) error {
	t.Lang = LangCode(c.Query("lang"))
	t.DevType = DevType(c.Query("dev_type"))
	return nil
}

func (t *UploadFileParams) Normalize() {

}

func (t *UploadFileParams) Valid() error {
	if t == nil {
		return errors.New("params is nil")
	}

	return nil
}

type UploadFileBody struct {
	// 上传文件类型：
	// - 0：头像
	// - 1：附件
	Type FileType `json:"type,omitempty"`
	// 文件
	File *FileHeader `json:"file"`
}

func (t *UploadFileBody) Bind(c *gin.Context) error {
	t.Type = FileType(tex.ToInt64(c.PostForm("type")))
	file, err := FormGinFile(c, "file")
	if err != nil {
		return err
	}
	t.File = file

	return nil
}

func (t *UploadFileBody) Normalize() {

}

func (t *UploadFileBody) Valid() error {
	if t == nil {
		return errors.New("body is nil")
	}
	if t.File == nil {
		return errors.New("file.is.nil")
	}
	if !t.File.ValidExts("jpg", "jpeg", "png", "gif") {
		return errors.New("file.ext.invalid")
	}
	if !t.File.ValidSize(4096) {
		return errors.New("file.size.too.large")
	}
	return nil
}

type UploadFileResponse struct {
	Response

	// 上传结果
	Data *UploadResult `json:"data,omitempty"`
}

func (w *Wrapper) UploadFile(c *gin.Context) {
	var err error
	var param = &UploadFileParams{}
	if err = w.bindAndValid(c, param); err != nil {
		w.logError("UploadFile.bindAndValid.err", zap.Error(err))
		w.reqErrorWrapperFunc(c, err)
		return
	}
	var body = &UploadFileBody{}
	if err = w.bindAndValid(c, body); err != nil {
		w.logError("UploadFile.bindAndValid.err", zap.Error(err))
		w.reqErrorWrapperFunc(c, err)
		return
	}
	w.logDebug("UploadFile", zap.Reflect("param", param), zap.Reflect("body", body))
	var res *UploadFileResponse
	if res, err = w.server.UploadFile(c, param, body); err != nil {
		w.logError("UploadFile.err", zap.Reflect("param", param), zap.Reflect("body", body), zap.Error(err))
		w.errorWrapperFunc(c, err)
		return
	}
	w.logDebug("UploadFile.rsp", zap.Reflect("param", param), zap.Reflect("body", body), zap.Reflect("res", res))
	c.JSON(http.StatusOK, res)
}

func (m *MockServer) UploadFile(c *gin.Context, params *UploadFileParams, body *UploadFileBody) (*UploadFileResponse, error) {
	return nil, nil
}
